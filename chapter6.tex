% Freerange VHDL
% Authors: Bryan Mealy, Fabrizio Tappero
% Date: May, 2011
%
% (C) 2011 B. Mealy, F. Tappero
%
% !TEX root = freerange_vhdl_master.tex
%
\chapter{VHDL Operators}
So far we have only implicitly mentioned the operators available VHDL. This section presents a complete list of operators as well as few examples of their use. A complete list of operators is shown in Table \ref{vhdl_operators_table}. This is followed by brief descriptions of some of the less obvious operators. Although you may not have an immediate need to use some of these operators, you should be aware that they exist. And although there are some special things you should know about some of these operators, not too much information is presented in this section.

\begin{table}
\centering
\footnotesize\textsf{\begin{tabular}{l|lllllll}
Operator type\\
\hline
\rowcolor{light-gray} logical & and & or & nand & nor & xor & xnor & not \\
relational & = & /= & $<$ & $<=$ & $>$ & $>=$ & \\
\rowcolor{light-gray} shift & sll & srl & sla & sra & rol & ror & \\
addition & + & - & & & & & \\
\rowcolor{light-gray} unary & + & - & & & & & \\
multiplying & * & / & mod & rem \\
\rowcolor{light-gray} others & ** & abs & / & & & & \\
\end{tabular}}
\caption{VHDL operators.}
\label{vhdl_operators_table}
\end{table}

Operators in VHDL are grouped into seven different types: logical, relational, shift, addition, unary, multiplying, and others. The ordering of this operator list is somewhat important because it presents the operators in the order of precedence. We said somewhat because your VHDL code should never rely on operator precedence to describe circuit behaviour. Reliance on obscure precedence rules tends to make the VHDL code cryptic and hard to understand. A liberal use of parenthesis is a better approach to VHDL coding.

The first column of Table \ref{vhdl_operators_table} lists the operators in precedence order with the logical operators having the highest precedence. Although there is a precedence order in the types of operators, there is not precedence order within each type of operator. In other words, the operators appearing in the rows are presented in no particular order. This means that the operators are applied to the given operands in the order they appear in the associated VHDL code.

\section{Logical Operators}
The logical operators are generally self-explanatory in nature. They have also been used throughout this book. The only thing worthy to note here is that the \texttt{not} operator has been included in the group of logical operators despite the fact that it is not technically a logic operation.

\section{Relational Operators}
The relational operators are generally self-explanatory in nature too. Many of them have been used in this book. A complete list of relational operators is provided in Table \ref{relational_operators_table}.

\begin{table}
\centering
\footnotesize\textsf{\begin{tabular}{l|l|l}
Operator & Name & Explanation\\
\hline
\rowcolor{light-gray} $=$ & equivalence & is some value equivalent to some other value? \\
$/=$ & non-equivalence & is some value not equivalent to some other value? \\
\rowcolor{light-gray} $<$ & less than & is some value less than some other value? \\
$<=$ &less than or equal & is some value less than or equal to some other value? \\
\rowcolor{light-gray} $>$ & greater than & is some value greater than some other value? \\
$>=$ & greater than or equal & is some value greater than or equal to some other value? \\
\end{tabular}}
\caption{VHDL relational operators with brief explanations.}
\label{relational_operators_table}
\end{table}

\section{Shift Operator}
There are three types of shift operators: simple shift, arithmetic shift, and rotates. Although these operators basically shift bits either left-to-right or right-to-left, there are a few basic differences which are listed below. The shift operators are listed in Table \ref{shift_operators_table}.
\begin{my_list}
\item Both the simple and arithmetic shifts introduce zeros into one end of the operand that is affected by the shift operation. In other words, zeros are fed into one end of the operand while bits are essentially lost from the other end. The difference between simple and arithmetic shifts is that in arithmetic shift, the sign-bit is never changed. For arithmetic shift lefts, zeros are stuffed in the right end of the operand. For arithmetic shift rights, the sign-bit (the left-most bit) is propagated right (the value of the left-most bit is fed into the left end of the operand).
\item Rotate operators grab a bit from one end of the word and stuff it into the other end. This operation is done independent of the value of the individual bits in the operand.
\end{my_list}
\begin{table}
\centering
\footnotesize\textsf{\begin{tabular}{l|l|l|l|l}
Operator & \multicolumn{2}{c|}{Name} & Example & Result \\
\hline
\multirow{2}{*}{simple} & ssl & shift  left & result $<=$ '110111' ssl 2 & '011100' \\
& ssr & shift right & result $<=$ '110111' ssr 3 & '000110' \\
\hline
\multirow{2}{*}{arithmetic} & sla & shift left arithmetic & result $<=$ '110011' sla 2 & '101100' \\
& sra & shift right arithmetic & result $<=$ '110011' sra 3 & '100010' \\
\hline
\multirow{2}{*}{rotate} & rol & rotate  left & result $<=$ '101000' rol 2 & '100010' \\
& ror & rotate right & result $<=$ '101001' ror 2 & '011010' \\
\hline
\end{tabular}}
\caption{VHDL shift operators with examples.}
\label{shift_operators_table}
\end{table}

\section{All the Other Operators}
The other groups of operators are generally used with numeric types. Since this section does not present numerical operations in detail, the operators are briefly listed below in Table \ref{shift_other_operators_table}. Special attention is given to the \texttt{mod}, \texttt{rem}, and \texttt{\&} operators. These operators are also limited to operating on specific types which are also not listed here.

\begin{table}[!b]
\centering
\footnotesize\textsf{\begin{tabular}{l|l|l|l}
\multicolumn{2}{c|}{Operator} & Name & Comment \\
\hline
\multirow{2}{*}{addition} & \texttt{+} & addition & \\
& \texttt{-} & substraction &  \\
\hline
\multirow{2}{*}{unary} & \texttt{+} & identity & \\
& \texttt{-} & negation &  \\
\hline
\multirow{4}{*}{multiplying} & \texttt{*} & multiplication &\\
& \texttt{/} & division & often limited to powers of two\\
& \texttt{mod} & modulus & can operate only on specific types\\
& \texttt{rem} & remainder & can operate only on specific types\\
\hline
\multirow{4}{*}{other} & \texttt{**} & exponentiation & often limited to powers of two\\
& \texttt{abs} & absolute value & \\
& \texttt{\&} & concatenation & can operate only on specific types\\
\hline
\end{tabular}}
\caption{All the other VHDL operators not listed so far.}
\label{shift_other_operators_table}
\end{table}

\section{The Concatenation Operator}
The concatenation operator, \texttt{\&}, is often a useful operator when dealing with digital circuits. There are many times when you will find a need to tack together two separate values. The concatenation operator has been seen in some previous example solutions. Some more examples of the concatenation operators are presented in Listing \ref{concat_operator}. 

\begin{lstlisting}[label=concat_operator, caption=Examples of the concatenation operator.]
signal A_val, B_val : std_logic_vector(3 downto 0); 
signal C_val : std_logic_vector(6 downto 0); 
signal D_val : std_logic_vector(7 downto 0); 

C_val <= A_val & "00"; 
C_val <= "11" & B_val; 
C_val <= '1' & A_val & '0'; 
D_val <= "0001" & C_val(3 downto 0); 
D_val <= A_val & B_val; 
\end{lstlisting}

\section{The Modulus and Remainder Operators}
There is often confusion about the differences between the remainder operator and the modulus operator, \texttt{rem} and \texttt{mod}, and the difference in their operation on negative and positive numbers. The definitions that VHDL uses for these operators are shown in Table \ref{rem_mod_def} while a few examples of these operators are provided in Table \ref{rem_mod_example}. A general rule followed by many programmers is to avoid using the \texttt{mod} operator when dealing with negative numbers. As you can see from the examples below, answers are sometime counter-intuitive. 

\begin{table}
\centering
\footnotesize\textsf{\begin{tabular}{l|l|l|l}
Operator & Name & Satisfies this Conditions & Comment\\
\hline
\multicolumn{1}{c|}{\texttt{rem}} & \multicolumn{1}{c|}{remainder} & 1. sign of (X \texttt{rem} Y) is the same as X \\
&& 2. abs (X \texttt{rem} Y) $<$ \texttt{abs} (X) & \texttt{abs} = absolute value\\
&& 3. X = (X/Y)*Y+(X \texttt{rem} Y) \\
\hline
\multicolumn{1}{c|}{\texttt{mod}} & \multicolumn{1}{c|}{modulus} & 1. sign of (X \texttt{mod} Y) is the same as X \\
&& 2. abs (X \texttt{mod} Y) $<$ \texttt{abs} (X) & \texttt{abs} = absolute value\\
&& 3. X = Y*N+(X \texttt{mod} Y) \\
\hline
\end{tabular}}
\caption{Definitions of \texttt{rem} and \texttt{mod} operators.}
\label{rem_mod_def}
\end{table}


\begin{table}[!b]
\centering
\footnotesize\textsf{\begin{tabular}{|c|c|}
\hline
\texttt\textbf{rem} & \texttt\textbf{mod}\\
\hline
\rowcolor{light-gray} 8 rem  5 =  3 & 8 mod  5 =  3\\
\hline
-8 rem  5 = -3 & -8 mod  5 =  2 \\
\hline
\rowcolor{light-gray} 8 rem -5 =  3 & 8 mod -5 = -2 \\
\hline
-8 rem -5 = -3 & -8 mod -5 = -3 \\
\hline
\end{tabular}}
\caption{Example of \texttt{rem} and \texttt{mod} operators.}
\label{rem_mod_example}
\end{table}

\section{Review of Almost Everything Up to Now}
VHDL is a programming language used to design, test and implement digital circuits. The basic design units in VHDL are the entity and the architecture which exemplify the general hierarchical approach of VHDL. The entity represents the black-box diagram of the circuit or the interface of the circuit to the outside world while the architecture encompasses all the other details of how the circuit behaves. 

The VHDL architecture is comprised of statements that describe the behaviour of the digital circuit. Because this is a hardware description language, statements in VHDL are primarily considered to execute concurrently. The idea of concurrency is one of the main themes of VHDL as one would expect since a digital circuit can be model as a set of logic gates that operate with concurrently. 

The main concurrent statement types in VHDL are the concurrent signal assignment statement, the conditional signal assignment statement, the selected signal assignment statement, and the process statement. The process statement is a concurrent statement which is comprised of exclusively sequential statements. The main types of sequential statements are the signal assignment statement, the  \texttt{if} statement, and the  \texttt{case} statement. The  \texttt{if} statement is a sequential version of conditional signal assignment statement while the  \texttt{case} statement is a sequential version of the selected signal assignment statement. The syntax of these statements and examples are given in the following table.

Coding styles in VHDL fall under the category of dataflow, behavioral, and structural models. Exclusive use of process statements indicates a behavioral model. The use of concurrent, conditional, and selective signal assignment indicate the use of a dataflow model. VHDL code describing more complex digital circuits will generally contain both features of all of these types of modelling. 

Since you should make no effort whatsoever to memorise VHDL syntax, it is recommendable the use of a cheat sheet to be always kept next to you as you perform VHDL modelling. Developing a true understanding of VHDL is what is going to make you into a good hardware designer. The ability to memorise VHDL syntax proves almost nothing. 

\section{Using VHDL for Sequential Circuits}
All the circuits we have examined up until now have been combinatorial logic circuits. In other words, none of the circuits we have examined so far are actually able to store information. This section show some of the various methods used to describe sequential circuits. We limit our discussion to VHDL behavioral models for several different flavors of D flip-flops. It is possible and in some cases desirable to use data-flow models to describe storage elements in VHDL, but it is much easier to use behaviour models.   

The few approaches for designing flip-flops shown in the next section cover just about all the possible functionality you could imagine when you make use of a D flip-flop. Once you understand these basics, you will be on your way to understand how to use VHDL to design Finite State Machines (FSMs). This book will examine FSMs in a later chapter.

\section{Simple Storage Elements Using VHDL}
The general approach for learning how to implement storage elements in digital design is to study the properties of a basic cross-coupled cell. The cross coupled cell forms what is referred to as a latch. The concept of a clocking signal is added to the device in order to enhance its controllability. Finally, some type of pulse narrowing circuitry is added to the clocking signal to get to the flop-flop. The flip-flop is nothing more than an edge-sensitive bit-storage device.

The study of a VHDL implementation of storage elements starts with the edge-triggered D flip-flop. The VHDL examples presented are the basic edge-triggered D flip-flop with an assortment of added functionality. 
\begin{leftbar}
\begin{minipage}{0.5\linewidth}
\noindent
\textbf{EXAMPLE 14.}
Write the VHDL code that describes a D flip-flop shown on the right. Use a behavioral model in your description.
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushright}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=1,framed]
%\draw[help lines] (0,0) grid (50,50);
% BOX
\draw (20,5) rectangle (35,20) node[midway]{$D-FF$};
% INPUTS
\small
\node (b) at (0,-2) {}; % this is to extend the pink area
\node (b) at (20,22.5) {}; % this is to extend the pink area
\node (a) at (20,2.5) {}; % this is the reference point
\draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[above]{D};
\draw [latex-] ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw [-latex] ($(a)+(15,10)$) -- ++(10,0) node[above]{Q};
\end{tikzpicture}
\end{flushright}
\end{minipage}
\end{leftbar}
\noindent
\textbf{SOLUTION.} The solution to example 14 is shown in listing \ref{exe_14}. Listed below are a few interesting things to note about the solution.
\begin{my_list}
\item The given architecture body describes the \texttt{my\_d\_ff} version of the \texttt{d\_ff\_x} entity.
\item Because this example required the use of a behavioral model, the architecture body is comprised primarily of a process statement. The statements within the process are executed sequentially. The process is executed each time a change is detected in any of the signals in the process's sensitivity list.  In this case, the statements within the process are executed each time there is a change in logic level of the \texttt{D} or \texttt{CLK} signals.
\item The \texttt{rising\_edge()} construct is used in the \texttt{if} statement to indicate that changes in the circuit output happens only on the rising edge of the \texttt{CLK} input. The \texttt{rising\_edge()} construct is actually an example of a VHDL function which has been defined in one of the included libraries. The way the VHDL code has been written makes the whole circuit synchronous, in fact changes in the circuit's output are synchronized with the rising edge of the clock signal. In this case, the action is a transfer of the logic level on the \texttt{D} input to the \texttt{Q} output. 
\item The process has the label \texttt{dff}. This is not required by the VHDL language but the addition of process labels promotes a self-commenting nature of the code and increases its readability and understandability. 
\end{my_list}
\begin{lstlisting}[label=exe_14, caption=Solution to example 14.]
----------------------------------------------
-- Model of a simple D Flip-Flop
----------------------------------------------
entity d_ff_x is 
	port ( D, CLK : in std_logic; 
		   Q : out std_logic); 
end d_ff_x; 
architecture my_d_ff of d_ff_x is 
begin
	dff:  process (D, CLK)
	begin
		if (rising_edge(CLK)) then
			Q <= D; 
		end if; 
	end process dff; 
end my_d_ff; 
\end{lstlisting}

The D flip-flop is best known and loved for its ability to store (save, remember) a single bit. The way that the VHDL code in listing \ref{exe_14} is able to store a bit is not however obvious. The bit-storage capability in the VHDL is implied by the way the VHDL code is interpreted. The implied storage capability comes about as a result of not providing a condition that indicates what should happen if the listed \texttt{if} condition is not met. In other words, if the \texttt{if} condition is not met, the device does not change the value of \texttt{Q} and therefore it must remember the current value. The remembering feature of the current value, or state, constitutes the famous bit storage quality of a flip-flop. If you have not specified what the output should be for every possible set of input conditions, the option taken by VHDL is not to change the current output. By definition, if the input changes to an unspecified state, the output remain unchanged. In this case, the output associated with the previous set of input can be thought of as being remembered. It is this mechanism, as strange and interesting as it is, that is used to induce memory in the VHDL code. 

In terms of the D flip-flop shown in example 14, the only time the output is specified is for that delta time associated with the rising edge of the clock. The typical method used to provide a catch-all condition in case the if condition is not met is with an \texttt{else} clause. Generally speaking, a quick way to tell if you have induced a memory element is to look for the presence of an \texttt{else} clause associated with the \texttt{if} statement. 

The previous two paragraphs are vastly important for understanding VHDL; the concept of inducing memory in VHDL is massively important to digital circuit design. The design of sequential circuits is dependent on this concept. This somewhat cryptic method used by VHDL to induce memory elements is a byproduct of behavioral modeling based solely on the interpretation of the VHDL source code. Even if you will only be using VHDL to design combinatorial circuits, you will most likely be faced with the understanding of these concepts. One of the classic warnings generated by the VHDL synthesizer is the notification that your VHDL code has generated a \texttt{latch}. Despite the fact that this is only a warning, if you did not intend to generate a latch, you should strive to modify your VHDL code in such as way as to remove this warning. Assuming you did not intend to generate a latch, the cause of your problem is that you have not explicitly provided an output state for all the possible input conditions. Because of this, your circuit will need to remember the previous output state so that it can provide an output in the case where you have not explicitly listed the current input condition. 

\begin{leftbar}
\begin{minipage}{0.5\linewidth}
\noindent
\textbf{EXAMPLE 15.}
Write the VHDL code that describes a D flip-flop shown on the right. Use a behavioral model in your description. Consider the \texttt{S} input to be an active-low, synchronous input that sets the \texttt{D} flip-flop outputs when asserted.
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushright}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=1,framed]
%\draw[help lines] (0,0) grid (50,50);
% BOX
\draw (20,5) rectangle (35,20) node[midway]{$D-FF$};
% INPUTS
\small
\node (b) at (0,-2) {}; % this is to extend the pink area
\node (b) at (20,22.5) {}; % this is to extend the pink area
\node (a) at (20,2.5) {}; % this is the reference point
\draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[above]{D};
\draw [latex-] ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw [latex-] ($(a)+(8.5,1.5)$) |- ++(-19,-5) node[above]{S};
\draw ($(a)+(8.5,1.8)$) circle (2pt);
% OUTPUTS
\draw [-latex] ($(a)+(15,10)$) -- ++(10,0) node[above]{Q};
\end{tikzpicture}
\end{flushright}
\end{minipage}
\end{leftbar}
\noindent
\textbf{SOLUTION.} The solution to example 15 is shown in listing \ref{exe_15}. There are few things of interest regarding this solution.
\begin{my_list}
\item The \texttt{S} input to the flip-flop is made synchronous by only allowing it to affect the operation of the flip-flop on the rising edge of the system clock. 
\item On the rising edge of the clock, the \texttt{S} input takes precedence over the \texttt{D} input because the state of the \texttt{S} input is checked prior to examining the state of the \texttt{D} input. In an \texttt{if-else} statement, once one condition evaluates as true, none of the other conditions is checked. In other words, the \texttt{D} input is transferred to the output only the rising edge of the clock and only if the \texttt{S} input is not asserted.
\end{my_list}
\begin{lstlisting}[label=exe_15, caption=Solution to example 15.]
---------------------------------------------------------------
-- RET D Flip-flop model with active-low synchronous set input.
---------------------------------------------------------------
entity d_ff_ns is 
    port (  D,S :  in  std_logic; 
            CLK :  in  std_logic; 
              Q :  out std_logic); 
end d_ff_ns;

architecture my_d_ff_ns of d_ff_ns is 
begin
   dff:  process (D,S,CLK)
   begin
      if (rising_edge(CLK)) then
         if (S = '0') then
            Q <= '1';
         else
            Q <= D;
         end if;
      end if;
   end process dff;
end my_d_ff_ns;
\end{lstlisting}

\begin{leftbar}
\begin{minipage}{0.5\linewidth}
\noindent
\textbf{EXAMPLE 16.}
Write the VHDL code that describes a \texttt{D} flip-flop shown on the right. Use a behavioral model in your description. Consider the \texttt{R} input to be an active-high, asynchronous input that resets the \texttt{D} flip-flop outputs when asserted.
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushright}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=1,framed]
%\draw[help lines] (0,0) grid (50,50);
% BOX
\draw (20,5) rectangle (35,20) node[midway]{$D-FF$};
% INPUTS
\small
\node (b) at (0,-2) {}; % this is to extend the pink area
\node (b) at (20,22.5) {}; % this is to extend the pink area
\node (a) at (20,2.5) {}; % this is the reference point
\draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[above]{D};
\draw [latex-] ($(a)+(-1.5,5)$) -- ++(-10,0) node[above]{CLK};
\draw [latex-] ($(a)+(8.5,2.5)$) |- ++(-19,-5) node[above]{S};
\draw ($(a)+(-1,5)$) circle (2pt);
% OUTPUTS
\draw [-latex] ($(a)+(15,10)$) -- ++(10,0) node[above]{Q};
\end{tikzpicture}
\end{flushright}
\end{minipage}
\end{leftbar}
\noindent
\textbf{SOLUTION.} The solution to example 16 is shown in listing \ref{exe_16}. You can probably glean the most information about asynchronous input and synchronous inputs by comparing the solutions to example 15 and example 16. A couple of interesting points are listed below. 
\begin{my_list}
\item The reset input is independent of the clock and takes priority over the clock. This prioritisation is done by making the reset condition the first condition in the \texttt{if} statement. Evaluation of the other conditions continues if the \texttt{R} input does not evaluate to a '1'.
\item The \texttt{falling\_edge()} function is used to make the D flip-flop falling-edge-triggered. Once again, this function is defined in one of the included libraries. 
\end{my_list}
\begin{lstlisting}[label=exe_16, caption=Solution to example 16.]
-------------------------------------------------------------------
-- FET D Flip-flop model with active-high asynchronous reset input.
-------------------------------------------------------------------
entity d_ff_r is 
    port (   D,R :  in  std_logic; 
             CLK :  in  std_logic; 
               Q :  out std_logic); 
end d_ff_r;

architecture my_d_ff_r of d_ff_r is 
begin
   dff:  process (D,R,CLK)
   begin
      if (R = '1') then 
         Q <= '0'; 
      elsif (falling_edge(CLK)) then 
         Q <= D; 
      end if; 
   end process dff; 
end my_d_ff_r; 
\end{lstlisting}    
The solutions of example 15 and example 16 represent what can be considered the standard VHDL approaches to handling synchronous and asynchronous inputs, respectively. The general forms of these solutions are actually considered templates for synchronous and asynchronous inputs by several VHDL references. As you will see later, these solutions form the foundation to finite state machine design using VHDL.

\begin{leftbar}
\begin{minipage}{0.5\linewidth}
\noindent
\textbf{EXAMPLE 17.}
Write the VHDL code that describes a T flip-flop shown on the right. Use a behavioral model in your description. Consider the \texttt{S} input to be an active-low, asynchronous input that sets the T flip-flop outputs when asserted.
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushright}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=1,framed]
%\draw[help lines] (0,0) grid (50,50);
% BOX
\draw (20,5) rectangle (35,20) node[midway]{$D-FF$};
% INPUTS
\small
\node (b) at (0,-2) {}; % this is to extend the pink area
\node (b) at (20,22.5) {}; % this is to extend the pink area
\node (a) at (20,2.5) {}; % this is the reference point
\draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[above]{D};
\draw [latex-] ($(a)+(-1.5,5)$) -- ++(-10,0) node[above]{CLK};
\draw [latex-] ($(a)+(8.5,2.5)$) |- ++(-19,-5) node[above]{S};
\draw ($(a)+(-1,5)$) circle (2pt);
% OUTPUTS
\draw [-latex] ($(a)+(15,10)$) -- ++(10,0) node[above]{Q};
\end{tikzpicture}
\end{flushright}
\end{minipage}
\end{leftbar}
\noindent
\textbf{SOLUTION.} The solution to example 17 is shown in listing \ref{exe_17}. This example has some massively important techniques associated with it that are well worth mentioning below.
\begin{my_list}
\item A unique quality of the D flip-flop is demonstrated in this implementation of a T flip-flop. The output of a D flip-flop is only dependent upon the \texttt{D} input and is not a function of the present output of the flip-flop. The output of a T flip-flop is dependent upon both the \texttt{T} input and the current output of the flip-flop. This adds a certain amount of extra complexity to the T flip-flop model as compared to the D flip-flop as is shown in listing \ref{exe_17}. The T flip-flop model in listing \ref{exe_17} uses a temporary signal in order to use the current state of the flip-flop as in input. In other words, since \texttt{Q} appears as a port to the entity it must be assigned a mode specifier, and in this case, it has been assigned a mode specifier of "out". Signals that are declared as outputs can therefore not appear on the right side of a signal assignment operator. The standard approach to bypassing this apparent limitation in VHDL is to use intermediate signals which, as opposed to port signals, do not have mode specifications and can thus be used as either inputs or outputs (can appear on both sides of the signal assignment operator) in the body of the architecture. The approach is to manipulate the intermediate signal in the body of the architecture but to also use a concurrent signal assignment statement to assign the intermediate signal to the appropriate output. Note that in the key statement in the solution shown in \ref{exe_17} that the intermediate signal appears on both sides of the signal assignment operator. This is a widely used approach in VHDL, please take time to understand and absorb it. And lastly on this note, there are other mode specifications that would allow you a different approach to bypassing this problem (namely, the use of the 'buffer' mode specification), but you should never use these in VHDL. The approach presented here is considered a good use of VHDL. 

\item This code uses the characteristics equation of a T flip-flop in its implementation. We technically used a characteristic equation when we implemented the D flip-flop but since the characteristic equation of a D flip-flop is relatively trivial, you may not have been aware of it.
\item Where there are certain advantages to using T flip-flops in come conditions, D flip-flops are generally the storage element of choice using VHDL. If you do not have a specific reason for using some type of flip-flop other than a D flip-flop, you probably should not. 
\end{my_list}

\begin{lstlisting}[label=exe_17, caption=Solution to example 17.]
-----------------------------------------------------------------
-- RET T Flip-flop model with active-low asynchronous set input.
-----------------------------------------------------------------
entity t_ff_s is 
    port ( T,S,CLK :  in  std_logic; 
                 Q :  out std_logic); 
end t_ff_s;

architecture my_t_ff_s of t_ff_s is 
   signal t_tmp : std_logic; -- intermediate signal declaration 
begin
   tff:  process (T,S,CLK)
   begin
      if (S = '0') then  
         Q <= '1'; 
      elsif (rising_edge(CLK)) then 
         t_tmp <= T XOR t_tmp; -- temp output assignment
      end if; 
   end process tff; 

   Q <= t_tmp; -- final output assignment
end my_t_ff_s; 
\end{lstlisting}    

\section{Inducing Memory: Data-flow vs. Behavioral Modelling}
A major portion of digital design deals with sequential circuits. Generally speaking, most sequential circuit design is about synchronising events to a clock edge. In other words, output changes only occur on an clock edge. The introduction to memory elements in VHDL presented in this section may lead the reader to think that memory in VHDL is only associated with behavioral modelling, but this is not the case. The same concept of inducing memory holds for data-flow modelling as well: not explicitly specifying an output for every possible input condition generates memory. And on this note, checking for unintended memory element generation is one of the duties of the digital designer. As you would imagine, memory elements add an element of needless complexity to the synthesised circuit.

One common approach for learning the syntax and mechanics of new computer languages is to implement the same task in as many different ways as possible. This approach utilises the flexibility of the language and is arguably a valid approach to learning a new language. This is also the case in VHDL. But, probably more so in VHDL than other languages, there are specific ways of doing things and these things should always be done in these specific ways. Although it would be possible to generate flip-flops using data-flow models, most knowledgeable people examining your VHDL code would not initially be clear as to what exactly you are doing. As far as generating synchronous memory elements go, the methods outlined in this section are simply the optimal method of choice. This is one area not be clever with. 

\section{Important Points}
\begin{my_list}
\item Storage elements in VHDL are induced by not specifying output conditions for every possible input condition.

\item Unintended generation of storage elements is generally listed by the synthesizer as ``latch generation''. Once again, latches are generated when there is an existing input condition to a circuit that does not have a corresponding output specification.

\item Memory elements can be induced by both data-flow and behavioral models.

\item If a signal declared in the entity declaration has a mode specifier of out, that signal cannot appear on the right side of a signal assignment operator. This limitation is bypassed by using intermediate signals for any functional assignments and later assigning the intermediate signal to the output signal using a concurrent signal assignment statement.

\item The mode specification of \texttt{buffer} should never be used in VHDL unless you are somebody who does not know any better and you are not interested in learning the best VHDL approach in this regard.
\end{my_list}

\section{Exercises: Basic Memory Elements}
%%%%%% EXERCISE 1 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 1.}
Provide a VHDL behavioral model of the D flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are an active low asynchronous preset and clear. Assume both the \texttt{S} and \texttt{R} inputs will never be asserted simultaneously. 
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{D};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}
%%%%%% EXERCISE 2 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 2.}
Provide a VHDL behavioral model of the D flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are an active low asynchronous preset and clear. Assume the \texttt{S} input takes precedence over the \texttt{R} input in the case where both are asserted simultaneously. 
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{D};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}
%%%%%% EXERCISE 3 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 3.}
Provide a VHDL behavioral model of the D flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are synchronous preset and clear. Assume both the \texttt{S} and \texttt{R} inputs will never be asserted simultaneously.  
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{D};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}
%%%%%% EXERCISE 4 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 4.}
Provide a VHDL behavioral model of the D flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are an active low asynchronous preset and clear. If both the \texttt{S} and \texttt{R} inputs are asserted simultaneously, the output of the flip-flop will toggle.   
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{D};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}
%%%%%% EXERCISE 5 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 5.}
Provide a VHDL behavioral model of the T flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are an active low asynchronous preset and clear. Assume both the \texttt{S} and \texttt{R} inputs will never be asserted simultaneously. Implement this flip-flop first using an equation description of the outputs and then using a behavioral description of the outputs.  
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{T};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}
%%%%%% EXERCISE 6 %%%%%%
\begin{minipage}{0.6\linewidth}
\textbf{EXERCISE 6.}
Provide a VHDL behavioral model of the T flip-flop shown on the right. The \texttt{S} and \texttt{R} inputs are an active low asynchronous preset and clear. Assume both the \texttt{S} and \texttt{R} inputs will never be asserted simultaneously.  
\end{minipage}
\begin{minipage}{0.47\linewidth}
\begin{flushleft}
\begin{tikzpicture}
[x=1mm,y=1mm,line width=0.8pt,scale=0.75,framed]
% GRID
%\draw[help lines] (0,0) grid (50,30);
% BOX
\draw (20,5) rectangle (35,25);
% INPUTS
\small
\node (a) at (20,2.5) {} circle (40pt); % this is the reference point
%\draw[red] ($(a)) circle (1pt);
\draw ($(a)+(8.5,24)$) |- ++(-19,3) node[above]{S};
\draw ($(a)+(8.5,23.2)$) circle (2pt);
\draw ($(a)+(0,20)$) -- ++(-10,0) node[above]{T};
\draw ($(a)+(0,5)$) -- ++(-10,0) node[above]{CLK};
\draw ($(a)+(0,6)$) -- ++(1.5,-1) -- ++(-1.5,-1); % CLK triangle
\draw ($(a)+(8.5,1.1)$) |- ++(-19,-3) node[above]{R};
\draw ($(a)+(8.5,1.6)$) circle (2pt);
% OUTPUTS
\draw ($(a)+(15,20)$) -- ++(10,0) node[above]{Q};
\draw ($(a)+(16.5,5)$) -- ++(8.5,0) node[above]{Q};
\draw ($(a)+(16,5)$) circle (2pt);
\end{tikzpicture}
\end{flushleft}
\end{minipage}




